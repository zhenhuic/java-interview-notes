[toc]

# JVM数据类型

基本类型和引用类型。

1. 基本类型

   - 数值类型
     - 整型
     - 浮点型
     - char类型
   - boolean类型
   - returnAddress类型（指向jvm指令的操作码的指针，在Java中没有与之对应的类型）。

2. 引用类型

   - 类类型
   - 数组类型
   - 接口类型
   - null

数组类型：数组有component类型和element类型，component类型就是数组去掉最外层维度后剩下的类型，可能还是一个数组类型（对于多维数组）。element类型就是数组里面存储的最小数据的类型，它必须是一个基本类型，类类型，或接口类型。对于一维数组的话，component类型和element类型是相同的。

# JVM内存区域

## 堆

## 方法区

运行时常量池，字段和方法数据，方法和构造函数的代码，还有特殊的方法用于类和实例的初始化，以及接口的初始化。

### 运行时常量池

运行时常量池就是类或接口的字节码文件里的常量池的运行时表示形式，它包含几种常量。如在编译时就已经知道的数字字面量值，和必须在运行时解析的方法和字段的引用。

运行时常量池分配在jvm的方法区，类或接口的运行时常量池在类或接口被jvm创建时才会构建。

## 程序计数器

每个线程都有自己的pc寄存器，任何时候一个线程只能运行一个方法的代码。如果方法不是native的，pc寄存器包含当前正在被执行的jvm指令地址，如果方法是native的，pc寄存器的值是未定义的。

## 虚拟机栈

每一个jvm线程都有一个私有的jvm栈，随着线程的创建而创建，栈中存储的是帧。

jvm栈和传统语言如C的栈相似，保存局部变量和部分计算结果，参与方法的调用和返回。jvm栈主要用于帧的出栈和入栈。

### 栈帧

每次当一个方法被调用时一个新的帧会被创建。当方法调用完成时，与之对应的帧会被销毁，无论是正常完成还是抛异常结束。所以帧是方法调用的具体体现形式，或称方法调用是以帧的形式进行的。

帧用来存储数据和部分计算结果，和执行动态链接，方法返回值，分发异常。

本地变量数组、操作数栈和一个对当前方法所在类的运行时常量池的引用。

在一个线程执行的任何时刻，都只会有一个帧是处于激活的。这个帧被称为当前帧，与之对应的方法被称为当前方法，方法所在的类被称为当前类，此时用到的本地变量数组和操作数栈也都是当前帧的。

当方法返回时，当前帧把方法执行的结果传回到上一帧，当上一帧被激活的同时当前帧会被丢弃。

#### 本地变量数组

每一帧都包含一个变量数组，就是本地变量存储的地方。

本地变量按索引寻址，第一个本地变量的索引是0。long和double需要消耗两个连续的索引，但却是按照较小的这个索引寻址的。

在方法被调用时，jvm使用本地变量来接收传递进来的参数值。在类（静态）方法调用时，所有参数被传入从索引0开始的连贯的本地变量数组里。

在实例（非静态）方法调用时，索引0处总是传入正在其上执行方法调用的那个对象的引用，（就是Java中的this了），所有参数被传入从1开始的连贯的本地变量数组里。

#### 操作数栈

每个帧包含一个后进先出的栈，用于存储正在执行的jvm指令的操作数，就是操作数栈。

当帧被创建时，操作数栈是空的，jvm提供一些指令用于加载常量值，本地变量值，字段值到操作数栈上，另一些jvm指令采用操作数栈上的操作数进行操作，并把结果放回到操作数栈上。

操作数栈也用于准备将要传递给方法调用的参数和接收方法调用返回的结果。

#### 动态链接

动态链接就是把符号方法引用转换为具体的方法引用，在必要时加载类来解析尚未明确的符号，把符号变量的访问转换为这些变量运行时所在存储结构的适合的偏移量（索引）。这样的方式又称为后期绑定。

## 本地方法栈

native方法不是用Java语言写的，为了支持它需要使用传统栈，如C语言栈。不过jvm不能加载native方法，所以也不需要提供native方法需要的栈。

## 方法调用

一个方法调用正常完成（即没有抛异常）时，会根据所返回的值的类型执行一个适合的return指令，当前帧会去恢复调用者的状态，包括它的本地变量和操作数栈，使调用者的程序计数器适合的递增来跳过刚刚的那个方法调用指令。

返回值会被放到调用者帧的操作数栈上，然后继续执行调用者方法的帧。

一个方法在调用时抛出了异常，且这个异常没有在这个方法内被捕获处理，将会导致这个方法调用的突然结束，这种情况下永远不会向方法的调用者返回一个值。

## `<init>`和`<clinit>`方法

每一个用Java写的构造函数都以一个实例初始化方法出现，且都是特殊的名字，就是`<init>`，这个名字是编译器提供的。实例初始化方法只能在jvm内部使用invokespecial这个指令调用，且只能在尚未初始化的类实例上调用。

一个类或接口最多可以有一个类或接口初始化方法，通过调用这个方法被初始化。类或接口的初始化方法也有特殊的名字，就是`<clinit>`，该方法没有参数，且返回值是void。

# 垃圾回收

[看完这篇垃圾回收，和面试官扯皮没问题了（现在点外卖是天价！）](https://mp.weixin.qq.com/s/_AKQs-xXDHlk84HbwKUzOw)

## Java对象的内存分配过程 TLAB

[Java堆内存是线程共享的！面试官：你确定吗？](https://mp.weixin.qq.com/s/Wws24Fhg1nH4dHvtcFYi2g)

## finalize什么时候执行

## OOM分析及解决

### 为什么会OOM

- 内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。

- 内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。

### 常见的OOM情况

- java.lang.OutOfMemoryError: Java heap space ------>java堆内存溢出

- java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即方法区溢出了

- java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出。

### OOM分析--heapdump

1. dump堆的内存镜像，可以采用如下两种方式：

   - 设置JVM参数-XX:+HeapDumpOnOutOfMemoryError，设定当发生OOM时自动dump出堆信息。不过该方法需要JDK5以上版本。

   - 使用JDK自带的jmap命令。`jmap -dump:format=b,file=heap.bin <pid>`   其中pid可以通过jps获取。

2. 对dump出的文件进行分析，从而找到OOM的原因：

   - MAT: eclipse memory analyzer, 基于eclipse RCP的内存分析工具。
   - jhat：JDK自带的java heap analyze tool，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言OQL，分析相关的应用后，可以通过 `http://localhost:7000` 来访问分析结果。

## Java进程CPU使用率高排查

1. jps 获取Java进程的PID。

2. jstack pid >> java.txt 导出CPU占用高进程的线程栈。

3. top -H -p PID 查看对应进程的哪个线程占用CPU过高。

4. echo “obase=16; PID” | bc 将线程的PID转换为16进制,大写转换为小写。

5. 在第二步导出的Java.txt中查找转换成为16进制的线程PID。找到对应的线程栈。

6. 分析负载高的线程栈都是什么业务操作。优化程序并处理问题。
