# MySQL

## 怎样会造成死锁

## 慎用外键

1. 外键的优点

    外键约束使得程序员更不容易将不一致性引入数据库，而且设计合适外键有助于以文档方式记录表间关系。

2. 外键的缺点

    但这些优点是以服务器为执行必要的检查而花费额外的开销为代价的。服务器进行额外的检查会影响性能。

    其次外键对并发性能的影响很大，因每次修改数据都需要去另外一个表检查数据，需要获取额外的锁（以确保事务完成之前，父表的记录不会被删除）高并发环境下出现性能问题，更好的办法是**在应用层实现外键约束**。

[MySQL外键字段必须索引](https://blog.csdn.net/sweeper_freedoman/article/details/61426736)

## drop，delete与truncate的区别

[drop,delete与truncate的区别](https://www.jianshu.com/p/9d6c6e5d676f)

## 加载MySQL驱动类为什么用Class.forName()方法

## 一条SQL的执行过程

[SQL语句执行过程详解](https://juejin.im/post/6844903655439597582)

![向MySQL发送一个请求MySQL做了什么](https://user-gold-cdn.xitu.io/2018/8/12/1652e56415e9a6f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。
3. 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。
4. MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。
5. 将结果返回给客户端。

## 建立索引的规则

1. 有**外键**的数据列一定要建立索引；
2. 在需要根据**范围**进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
3. 在需要**排序**的列上创建索引；
4. 在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度；
5. 在经常需要**搜索**的列上。

## 建立索引需要避免的点

1. 避免在重复值较多的列建立索引；
2. 最好不要给数据库留 NULL；
3. in 和 not in 也要慎用，否则会导致全表扫描。

## 数据库优化

### 列的数据结构长度选择

1. 选择合适的数据结构，尽量使用短的数据；
2. 尽量使用定长的char；
3. 使用timestamp代替datetime。

### 建立索引

一般先加上sql_no_cache用explain预跑一下SQL语句，看看这条语句

1. 工单状态、创建时间、创建人ID 建立联合索引；

2. 工位ID、工单状态 建立联合索引；

3. 使用覆盖索引，避免回表，不要写 select *；考虑索引下推。

4. 产品名称、原料名称 分别建立索引，模糊查询先使用最左前缀，如果查不到再使用%放前面的查询。

5. 给字符串加索引，倒序存储。

### 查询语句的优化

1. 按产品名称、原料名称进行模糊查询，like 查询，把先使用最左前缀，如果查不到再使用%放前面的查询；

2. 大多是多对多的关系，多对多需要创一个关系表，所以多表连接查询比较多，尽量是小表驱动大表；

3. 避免使用关联子查询，转成连接查询。

### 按年份将工单表进行分表

按年份对工单表进行水平拆分，查询的时候按年份查表。

## 唯一索引和普通索引

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。

要判断表中是否存在这个数据，而这必须要将数据页读入内存才能判断，如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。

因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

### change buffer

在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。

在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。

## 开启慢查询日志

pt_query_digest工具分析
